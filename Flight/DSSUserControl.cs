//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(DSSController))]
public class DSSUserControl : MonoBehaviour
{
	#region Unity Visible Variables

	[SerializeField] private Vector3 leftForce;
	[SerializeField] private Vector3 rightForce;

	#endregion Unity Visible Variables

	#region Private Members

	private Dictionary<Vector3, Vector3> forceVectors;

	#endregion Private Members

	#region Control Factors

	[SerializeField]private float totalThrottle = 0.0f;
	[SerializeField]private float tiltControl = 0.0f;
	[SerializeField]private float trimControl = 0.0f;
	[SerializeField]private float balControl = 0.0f;

	#endregion Control Factors

	// these max angles are only used on mobile, due to the way pitch and roll input are handled
	public float maxRollAngle = 80;
	public float maxPitchAngle = 80;
	
	// reference to the aeroplane that we're controlling
	private DSSController controller;
	private Animator animator;

	void Awake ()
	{
		// Set up the reference to the aeroplane controller.
		controller = GetComponent<DSSController>();
		animator = GetComponent<Animator>();
		animator.SetInteger("GearState", -1);
	}

	void CalculateForce()
	{
		forceVectors = new Dictionary<Vector3, Vector3> ();
		if (totalThrottle > 0) 
		{
			//calculate net forces from engine
			foreach (var p in controller.PowerPlants.Values) 
			{
				if(p.dryThrust > 0 || p.afterBurnThrust > 0)
				{
					var newForce = Quaternion.Euler(p.transform.localEulerAngles) * Vector3.forward * p.thrust * p.afterBurnThrust;
					var newCenter = p.transform.localPosition;
					forceVectors[newCenter] = newForce;
				}
			}
		}
	}

	void ReadInput()
	{
		if(controller.PowerPlants.Count >= 5)
		{
			tiltControl = (float)Math.Min (Math.Max (-1, tiltControl), 1);
			trimControl = (float)Math.Min (Math.Max (-1, trimControl), 1);
			totalThrottle = (float)Math.Min (Math.Max (0, totalThrottle), 2);
			float tiltAdjust = tiltControl * 15;
			float trimAdjust = trimControl * 15;
			float leftAdjust = 1.0f - balControl;
			float rightAdjust = 1.0f + balControl;

			controller.PowerPlants [0].transform.localRotation = Quaternion.Euler(new Vector3(trimAdjust + tiltAdjust,180,0));
			controller.PowerPlants [1].transform.localRotation = Quaternion.Euler(new Vector3(trimAdjust - tiltAdjust,180,0));
			controller.PowerPlants [0].thrust = leftAdjust * totalThrottle;
			controller.PowerPlants [1].thrust = rightAdjust * totalThrottle;
			controller.PowerPlants [2].thrust = controller.PowerPlants [0].thrust;
			controller.PowerPlants [3].thrust = controller.PowerPlants [1].thrust;

			controller.PowerPlants [4].thrust = totalThrottle;
			controller.PowerPlants [5].thrust = totalThrottle;

			foreach (var p in controller.PowerPlants.Values) 
			{
				if(totalThrottle > 0)
				{
					p.thrust = Mathf.Clamp(p.thrust, 0, 1);
				}
				else
				{
					p.thrust = -1;
				}
			}
		}
	}

	void FixedUpdate()
	{
		// Read input for the pitch, yaw, roll and throttle of the aeroplane.
		#if CROSS_PLATFORM_INPUT
		tiltControl = CrossPlatformInput.GetAxis("Horizontal");
		trimControl = CrossPlatformInput.GetAxis("Vertical");
		balControl = CrossPlatformInput.GetAxis("Z");
		var thrustChange = CrossPlatformInput.GetAxis("Mouse ScrollWheel");
		if(thrustChange != 0)
		{
			totalThrottle += thrustChange;
		}
		thrustChange = CrossPlatformInput.GetAxis("Slider");
		if(thrustChange != 0)
		{
			totalThrottle = thrustChange;
		}
		totalThrottle = Mathf.Clamp(totalThrottle, 0, 1);

		//bool airBrakes = CrossPlatformInput.GetButton("Fire1");
		#else
		float roll = Input.GetAxis("Horizontal");
		float pitch = Input.GetAxis("Vertical");
		bool airBrakes = Input.GetButton("Fire1");
		#endif

		ReadInput ();

		CalculateForce ();

		//AdjustInputForMobileControls(ref roll, ref pitch, ref throttle);

		// Pass the input to the aeroplane
		controller.Move(forceVectors);
	}
	
	private void AdjustInputForMobileControls(ref float roll, ref float pitch, ref float throttle)
	{
		#if MOBILE_INPUT
		// because mobile tilt is used for roll and pitch, we help out by
		// assuming that a centered level device means the user
		// wants to fly straight and level! 
		
		// this means on mobile, the input represents the *desired* roll angle of the aeroplane,
		// and the roll input is calculated to achieve that.
		// whereas on non-mobile, the input directly controls the roll of the aeroplane.
		
		float intendedRollAngle = roll * maxRollAngle * Mathf.Deg2Rad;
		float intendedPitchAngle = pitch * maxPitchAngle * Mathf.Deg2Rad;
		roll = Mathf.Clamp( (intendedRollAngle - aeroplane.RollAngle) , -1, 1);
		pitch = Mathf.Clamp( (intendedPitchAngle - aeroplane.PitchAngle) , -1, 1);
		
		// similarly, the throttle axis input is considered to be the desired absolute value, not a relative change to current throttle.
		float intendedThrottle = throttle * 0.5f + 0.5f;
		throttle = Mathf.Clamp(intendedThrottle - aeroplane.Throttle, -1, 1);
		#endif
	}
}

